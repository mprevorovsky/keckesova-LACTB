---
title: "RNA-seq analysis of LACTB-related changes in gene expression in human cells"
author: "Martin Převorovský, prevorov@natur.cuni.cz, http://www.GenoMik.cz"
output: html_document
---


```{r setup, message=FALSE}
library(rtracklayer)
library(GenomicAlignments)
library(DESeq2)
library(gplots)

knitr::opts_chunk$set(echo = TRUE)

genome_dir <- './genome/'
bam_dir <- './BAM_RNA-seq/'
coverage_dir <- './coverage_RNA-seq/'
QC_dir <- './QC_RNA-seq/'
QC_trim_dir <- './QC_trim_RNA-seq/'
image_dir <- './images/'
deg_dir <- './DEG_RNA-seq/'
#genome_gff <- paste0(genome_dir, 'Schizosaccharomyces_pombe_all_chromosomes.gff3')
```

Variables for shell scripts are stored in the file "shell_variables_RNA-seq.sh" and can be modified as needed:

```{bash list_variables}
cat shell_variables_RNA-seq.sh
```


# Getting the raw RNA-seq read datasets

THIS SECTION WILL ONLY BECOME RELEVANT ONCE THE SEQUENCING DATA ARE PUBLIC in ARRAYEXPRESS

All data and metadata can be obtained from ArrayExpress at https://www.ebi.ac.uk/arrayexpress/experiments/XXXXXXXX/.

```{bash, eval=FALSE, message=FALSE}
source shell_variables_RNA-seq.sh

wget -N --no-verbose https://www.ebi.ac.uk/arrayexpress/files/XXXXXXXX/XXXXXXXX.sdrf.txt
mapfile -t ftp_links < <(tail -n +2 XXXXXXXX.sdrf.txt | cut -f30)
mapfile -t ftp_names < <(tail -n +2 XXXXXXXX.sdrf.txt | cut -f28)

mkdir -p "${fastq_dir}"
for i in ${!ftp_links[@]};
do
  wget --no-verbose -O "${fastq_dir}${ftp_names[${i}]}" "${ftp_links[${i}]}"
done
```


# human genome annotation and index

downloaded `r date()`

* GRCh38 genome annotation was downloaded from Ensembl

* GRCh38 genome index for HISAT2 was downloaded from the Amazon open data repository

```{bash, message=FALSE, eval=FALSE}
source shell_variables_RNA-seq.sh

mkdir -p "${genome_dir}"

# genome annotation
wget -N --no-verbose --directory-prefix="${genome_dir}"  http://ftp.ensembl.org/pub/release-103/gff3/homo_sapiens/Homo_sapiens.GRCh38.103.chr.gff3.gz

# genome index for HISAT2
wget -N --no-verbose --directory-prefix="${genome_dir}" https://genome-idx.s3.amazonaws.com/hisat/grch38_tran.tar.gz


# genome sequence
#wget -N --no-verbose --directory-prefix="${genome_dir}" http://ftp.ensembl.org/pub/release-103/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.toplevel.fa.gz
#gzip -fd "${genome}"
```


# QC of raw sequence reads

* strand-specific libraries were sequenced at the Institute of Molecular Genetics, Czech Academy of Sciences

* Technical quality of library construction and sequencing run was tested using fastQC.

```{bash}
fastqc --version
multiqc --version
```

```{bash, eval=FALSE}
source shell_variables_RNA-seq.sh

mkdir -p "${QC_dir}"
mapfile -t fastq_files < <(ls -1 "${fastq_dir}" | grep "${fastq_file_ext}")
for i in ${fastq_files[@]};
do
  fastqc --quiet --outdir "${QC_dir}" --threads "${CPU}" "${fastq_dir}${i}"
done

multiqc -f -m fastqc -i RNA-seq -o "${QC_dir}" "${QC_dir}"
```

Results of QC:

* 76 nt SE reads

* 17.2-22.1M reads per sample

* read quality scores deteriorate towards the 3' end, trimming will be needed

* very small adapter contamination detected (in < 1% reads) and will be trimmed

* all samples give an error on read duplication levels (normal for RNA-seq from a small genome)

* all FASTQ files give warning/error on per base sequence content (normal for random-primed RT)

* 6 FASTQ files give warning on overrepresented sequences (TruSeq adapters)


# Read trimming

* remove Illumina adapters

* trim parts of the reads where average base quality in a 4 nt window drops below 20

* only keep trimmed reads that are at least 20 nt long

```{bash}
source shell_variables_RNA-seq.sh

java -jar "${trimmomatic_dir}trimmomatic-0.39.jar" -version
```

```{bash, eval=FALSE}
source shell_variables_RNA-seq.sh

mkdir -p "${fastq_trim_dir}"
fastq_files=( $(ls -1 "${fastq_dir}") )
for i in ${fastq_files[@]};
do
  java -jar "${trimmomatic_dir}trimmomatic-0.39.jar" SE -phred33 -threads "${CPU}" "${fastq_dir}${i}" "${fastq_trim_dir}${i}.trim.fastq.gz" ILLUMINACLIP:"${trimmomatic_dir}adapters/TruSeq3-PE-2.fa:2:30:10" SLIDINGWINDOW:4:20 MINLEN:20
done
```


# QC of quality-trimmed sequence reads

Effects of trimming were determined by `fastQC`.

```{bash, eval=FALSE}
source shell_variables_RNA-seq.sh

mkdir -p "${QC_trim_dir}"
fastq_files=( $(ls -1 "${fastq_trim_dir}") )
for i in ${fastq_files[@]};
do
  fastqc --quiet --outdir "${QC_trim_dir}" --threads "${CPU}" "${fastq_trim_dir}${i}"
done

multiqc -f -m fastqc -i RNA-seq_trimmed -o "${QC_trim_dir}" "${QC_trim_dir}"
```

Results of QC:

* dropped 4.6-6.6% of reads

* 20-65 nt reads (vast majority of reads are >63 nt)

* read quality scores now OK

* adapters were removed

* 2 samples give warning on GC content (not sure why)


# Read mapping into *S. pombe* genome

```{bash}
hisat2 --version
samtools --version
```

```{bash, eval=FALSE}
source shell_variables_RNA-seq.sh

# build HISAT2 index
hisat2-build --quiet -p "${CPU}" "${genome}" "${genome}"

# map
mkdir -p "${bam_dir}"
mapfile -t fastq_files < <(ls -1 "${fastq_trim_dir}")
for i in ${fastq_files[@]};
do
	infile="${fastq_trim_dir}${i}"
	outfile="${bam_dir}${i}.bam"
  echo "${outfile}"
	hisat2 -x "${genome}" -U "${infile}" --threads "${CPU}" --max-intronlen 2600 -k 15 --summary-file "${outfile}.log" | samtools view -b -F 256 --threads "${CPU}" - | samtools sort --threads "${CPU}" -o "${outfile}" - 
	samtools index "${outfile}"
	samtools view -c --threads "${CPU}" "${outfile}"
done
```

Notes

* Since signal is expected at repeat regions, HISAT was set to search for up to 15 matching positions (this allows even for testing all Tf2 and dh/dg repeats in the genome), then only the best (marked as primary by HISAT) alignment was kept.

* Mapping rate was >98%.


# QC of mapped samples

WARNING - completion of this step can take A LOT of time!

```{bash}
deeptools --version
```

```{bash, eval=FALSE}
source shell_variables_RNA-seq.sh

mkdir -p "${image_dir}"
mapfile -t bam_files < <(ls -1 -d "${bam_dir}"* | grep "\.bam$")
multiBamSummary bins --binSize "${bin_size}" -p "${CPU}" -o "${bam_dir}${bam_summary_file}" --bamfiles "${bam_files[@]}"
plotPCA -in "${bam_dir}${bam_summary_file}" -o "${image_dir}RNA-seq_plotPCA.pdf"
plotCorrelation -in "${bam_dir}${bam_summary_file}" -o "${image_dir}RNA-seq_plotCorrelation.pdf" --corMethod pearson --whatToPlot heatmap --removeOutliers
```

* Samples nicely cluster together according to attributes: asynchronous / synchronized, and WT / nse3mut.


# Calculate genome coverage tracks

```{bash, eval=FALSE}
source shell_variables_RNA-seq.sh

mkdir -p "${coverage_dir}"

# calculate coverage
mapfile -t bam_files < <(ls -1 "${bam_dir}" | grep "\.bam$")
for i in ${!bam_files[@]};
do
	input_file="${bam_dir}${bam_files[${i}]}"
	bamCoverage --binSize "${bin_size}" --normalizeUsing CPM -p "${CPU}" --bam "${input_file}" -o "${coverage_dir}${bam_files[${i}]}.bw"
done

# average coverage tracks across biological replicates
samples=("WT_async" "WT_HU" "nse3mut_async" "nse3mut_HU")
lib_IDs=("1|2|9|10" "7|8|15|16" "3|4|11|12" "5|6|13|14")
for i in {0..3};
do
  mapfile -t bw_files < <(ls -1 -d "${coverage_dir}"* | grep -E "_(${lib_IDs[${i}]})_.*\.bam\.bw$")
  wiggletools mean "${bw_files[@]}" | wigToBigWig -itemsPerSlot="${bin_size}" stdin "${genome_dir}chrom.sizes" "${coverage_dir}${samples[${i}]}.mean.bw"
done
```

Notes

* Checked visually in IGV → OK.

* Samples are very coherent across replicates.

* Stress genes are noticebly induced in HU.


# Identify differentially expressed genes

## Generate gene-level counts tables.

* Raw count data are needed for DEG calling in `DESeq2`.

* TPM-normalized (Transcripts Per Million) count data are suitable for general comparisons of the samples.

```{r, eval=TRUE}
gff <- import.gff3(genome_gff)
gff.genes <- gff[gff$type == 'gene', ]
bam_files <- list.files(bam_dir, full.names = TRUE, pattern = '\\.bam$')
bam <- BamFileList(bam_files, yieldSize = 1000000)

sample_info <- read.delim('sampleInfo', stringsAsFactors = FALSE, header = TRUE, sep = '\t')
sample_info[, 'cultivation_run'] <- factor(sample_info[, 'cultivation_run'])
sample_info[, 'genotype'] <- factor(sample_info[, 'genotype'])
sample_info[, 'sync'] <- factor(sample_info[, 'sync'])
names(bam) <- sample_info$sample_ID

se <- summarizeOverlaps(gff.genes,
                        bam,
                        mode = 'Union',
                        singleEnd = TRUE,
                        ignore.strand = FALSE,
                        preprocess.reads = invertStrand)
rownames(se) <- gff.genes$ID
colData(se) <- cbind(colData(se), sample_info)
#save(se, file = 'se.rda')
#load(file = 'se.rda')

counts <- assay(se)

# normalize to get TPM values (transcripts per million)
gene_widths <- width(gff.genes)
counts.norm <- counts
for (i in 1:nrow(counts.norm)){
  counts.norm[i, ] <- counts.norm[i, ] / gene_widths[i]
}
count_sums <- colSums(counts.norm) / 1000000
for (i in 1:length(count_sums)){
  counts.norm[, i] <- counts.norm[, i] / count_sums[i]
}

counts <- cbind(gff.genes$Name, counts)
counts.norm <- cbind(gff.genes$Name, counts.norm)
colnames(counts)[1] <- 'gene_name'
colnames(counts.norm)[1] <- 'gene_name'
write.csv(counts, file = paste0(coverage_dir, 'counts.csv'), quote = FALSE)
write.csv(counts.norm, file = paste0(coverage_dir, 'counts.TPM-normalized.csv'), quote = FALSE)
rm(gene_widths, count_sums)
```

## DEG calling

```{r, eval=TRUE}
# Benjamini-Hochberg p value adjustment (FDR)
padj_threshold <- 0.05

dir.create(deg_dir, showWarnings = FALSE)

# nse3mut asynchronous vs WT asynchronous
dds <- DESeqDataSet(se, design = ~ cultivation_run + genotype)
dds <- dds[, dds$sync =='async'] # remove HU samples
dds$sync <- droplevels(dds$sync) # remove factor levels without samples
dds$genotype <- relevel(dds$genotype, ref = 'WT') # change order of factor levels to get mut/WT fold change (= define the reference)
dds <- DESeq(dds)
res <- results(dds, alpha = padj_threshold)
summary(res[res$padj <= padj_threshold & !is.na(res$padj), ])
res <- cbind(counts[, 'gene_name'], res)
colnames(res)[1] <- 'gene_name'
write.csv(res, file = paste0(deg_dir, 'DESeq2results_nse3mut-async_vs_WT-async.csv'), quote = FALSE)
res.sig <- res[which(res$padj <= padj_threshold), ]
res.sig <- res.sig[order(res.sig$log2FoldChange), ]
write.csv(res.sig, file = paste0(deg_dir, 'DESeq2results_nse3mut-async_vs_WT-async.SIG.csv'), quote = FALSE)
rm(res, res.sig, dds)

# nse3mut HU vs WT HU
dds <- DESeqDataSet(se, design = ~ cultivation_run + genotype)
dds <- dds[, dds$sync =='HU'] # remove asynchronous samples
dds$sync <- droplevels(dds$sync) # remove factor levels without samples
dds$genotype <- relevel(dds$genotype, ref = 'WT') # change order of factor levels to get mut/WT fold change (= define the reference)
dds <- DESeq(dds)
res <- results(dds, alpha = padj_threshold)
summary(res[res$padj <= padj_threshold & !is.na(res$padj), ])
res <- cbind(counts[, 'gene_name'], res)
colnames(res)[1] <- 'gene_name'
write.csv(res, file = paste0(deg_dir, 'DESeq2results_nse3mut-HU_vs_WT-HU.csv'), quote = FALSE)
res.sig <- res[which(res$padj <= padj_threshold), ]
res.sig <- res.sig[order(res.sig$log2FoldChange), ]
write.csv(res.sig, file = paste0(deg_dir, 'DESeq2results_nse3mut-HU_vs_WT-HU.SIG.csv'), quote = FALSE)
rm(res, res.sig, dds)

# nse3mut HU vs nse3mut async
dds <- DESeqDataSet(se, design = ~ cultivation_run + sync)
dds <- dds[, dds$genotype =='nse3mut'] # remove WT samples
dds$genotype <- droplevels(dds$genotype) # remove factor levels without samples
dds$sync <- relevel(dds$sync, ref = 'async') # change order of factor levels to get HU/async fold change (= define the reference)
dds <- DESeq(dds)
res <- results(dds, alpha = padj_threshold)
summary(res[res$padj <= padj_threshold & !is.na(res$padj), ])
res <- cbind(counts[, 'gene_name'], res)
colnames(res)[1] <- 'gene_name'
write.csv(res, file = paste0(deg_dir, 'DESeq2results_nse3mut-HU_vs_nse3mut-async.csv'), quote = FALSE)
res.sig <- res[which(res$padj <= padj_threshold), ]
res.sig <- res.sig[order(res.sig$log2FoldChange), ]
write.csv(res.sig, file = paste0(deg_dir, 'DESeq2results_nse3mut-HU_vs_nse3mut-async.SIG.csv'), quote = FALSE)
rm(res, res.sig, dds)
```


# DEG analysis

* dbl2KO expression data were obtained from https://doi.org/10.1093/nar/gkab027 (supplementary table S3).

```{r, eval=TRUE}
fold_threshold <- log2(1.5)

res.async <- read.csv(paste0(deg_dir, 'DESeq2results_nse3mut-async_vs_WT-async.SIG.csv'), row.names = 1)
res.HU <- read.csv(paste0(deg_dir, 'DESeq2results_nse3mut-HU_vs_WT-HU.SIG.csv'), row.names = 1)
res.nse3mut <- read.csv(paste0(deg_dir, 'DESeq2results_nse3mut-HU_vs_nse3mut-async.SIG.csv'), row.names = 1)
dbl2 <- read.delim(paste0(deg_dir, 'dbl2_DEGs'), header = TRUE, stringsAsFactors = FALSE)

res.async.up <- res.async[res.async$log2FoldChange >= fold_threshold, ]
res.async.down <- res.async[res.async$log2FoldChange <= -1 * fold_threshold, ]
write.csv(res.async.up, file = paste0(deg_dir, 'async_UP_stringent.csv'), quote = FALSE)
write.csv(res.async.down, file = paste0(deg_dir, 'async_DOWN_stringent.csv'), quote = FALSE)

res.HU.up <- res.HU[res.HU$log2FoldChange >= fold_threshold, ]
res.HU.down <- res.HU[res.HU$log2FoldChange <= -1 * fold_threshold, ]
write.csv(res.HU.up, file = paste0(deg_dir, 'HU_UP_stringent.csv'), quote = FALSE)
write.csv(res.HU.down, file = paste0(deg_dir, 'HU_DOWN_stringent.csv'), quote = FALSE)

res.nse3mut.up <- res.nse3mut[res.nse3mut$log2FoldChange >= fold_threshold, ]
res.nse3mut.down <- res.nse3mut[res.nse3mut$log2FoldChange <= -1 * fold_threshold, ]

dbl2.up <- dbl2[dbl2$fold.change.dbl2.wt >= 2 ^ fold_threshold, ]
dbl2.down <- dbl2[dbl2$fold.change.dbl2.wt <= round(1 / (2 ^ fold_threshold), 2), ]

venn(list(nse3mut_async_DOWN = rownames(res.async.down), 
          nse3mut_HU_DOWN = rownames(res.HU.down),
          dbl2_DOWN = dbl2.down$systematic.ID))
tmp <- venn(list(nse3mut_async_UP = rownames(res.async.up), 
                 nse3mut_HU_UP = rownames(res.HU.up), 
                 dbl2_UP = dbl2.up$systematic.ID))
core_shared <- attr(tmp, 'intersections')$`nse3mut_async_UP:nse3mut_HU_UP:dbl2_UP`

barplot(c(nrow(res.async.up), nrow(res.HU.up), nrow(dbl2.up), length(core_shared)),
        ylab = 'genes',
        main = 'UPregulated DEGs',
        names.arg = c('nse3\nasync', 'nse3\nHU', 'dbl2', 'shared\nby_all'),
        las = 3)
barplot(c(nrow(res.async.up[grep('SPNCRNA', rownames(res.async.up)), ]), 
          nrow(res.HU.up[grep('SPNCRNA', rownames(res.HU.up)), ]), 
          nrow(dbl2.up[grep('SPNCRNA', dbl2.up$systematic.ID), ]),
          length(grep('SPNCRNA', core_shared))),
        add = TRUE, col = 'black')
legend('topright', legend = c('other', 'ncRNA'), fill = c('grey', 'black'), bty = 'n')

nse4_ChIP <- read.delim('./../Nse4_ChIP-seq_in_saga/genome/wt_filtered.narrowPeak.mRNA_overlaps.bed', 
                        header = FALSE, stringsAsFactors = FALSE)
nse4_ChIP <- unlist(strsplit(nse4_ChIP[, 4], 'Parent='))
nse4_ChIP <- nse4_ChIP[grep('ID=', nse4_ChIP, invert = TRUE)]

venn(list(nse3mut_async_UP = rownames(res.async.up), 
          nse3mut_HU_UP = rownames(res.HU.up), 
          dbl2_UP = dbl2.up$systematic.ID,
          nse4_ChIP = nse4_ChIP))

venn(list(nse3mut_async_DOWN = rownames(res.async.down), 
          nse3mut_HU_DOWN = rownames(res.HU.down), 
          dbl2_DOWN = dbl2.down$systematic.ID,
          nse4_ChIP = nse4_ChIP))
```

Less stringent DEG filtering (all up/down DEGs called by DESeq2 are used, no filtering on fold change)

```{r, eval = TRUE}
res.async.up.all <- res.async[res.async$log2FoldChange > 0, ]
res.async.down.all <- res.async[res.async$log2FoldChange < 0, ]

res.HU.up.all <- res.HU[res.HU$log2FoldChange > 0, ]
res.HU.down.all <- res.HU[res.HU$log2FoldChange < 0, ]

venn(list(nse3mut_async_UP = rownames(res.async.up.all), 
          nse3mut_HU_UP = rownames(res.HU.up.all), 
          #dbl2_UP = dbl2.up$systematic.ID,
          nse4_ChIP = nse4_ChIP))

venn(list(nse3mut_async_DOWN = rownames(res.async.down.all), 
          nse3mut_HU_DOWN = rownames(res.HU.down.all), 
          #dbl2_DOWN = dbl2.down$systematic.ID,
          nse4_ChIP = nse4_ChIP))
```


***

```{r}
sessionInfo()
```

