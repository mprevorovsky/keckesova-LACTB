---
title: "RNA-seq analysis of LACTB-related changes in gene expression in human cells"
author: "Martin Převorovský, prevorov@natur.cuni.cz, http://www.GenoMik.cz"
output: html_document
---

EXPERIMENT DESCRIPTION TO BE ADDED

```{r setup, message=FALSE}
library(rtracklayer)
library(GenomicAlignments)
library(DESeq2)

knitr::opts_chunk$set(echo = TRUE)

genome_dir <- './genome/'
bam_dir <- './BAM_RNA-seq/'
coverage_dir <- './coverage_RNA-seq/'
QC_dir <- './QC_RNA-seq/'
QC_trim_dir <- './QC_trim_RNA-seq/'
image_dir <- './images/'
deg_dir <- './DEG_RNA-seq/'
genome_gff <- paste0(genome_dir, 'Homo_sapiens.GRCh38.103.chr.gff3.gz')
```

Variables for shell scripts are stored in the file "shell_variables_RNA-seq.sh" and can be modified as needed:

```{bash list_variables}
cat shell_variables_RNA-seq.sh
```


# Getting the raw RNA-seq read datasets

THIS SECTION WILL ONLY BECOME RELEVANT ONCE THE SEQUENCING DATA ARE PUBLIC in ARRAYEXPRESS

All data and metadata can be obtained from ArrayExpress at https://www.ebi.ac.uk/arrayexpress/experiments/XXXXXXXX/.

```{bash, eval=FALSE, message=FALSE}
source shell_variables_RNA-seq.sh

wget -N --no-verbose https://www.ebi.ac.uk/arrayexpress/files/XXXXXXXX/XXXXXXXX.sdrf.txt
mapfile -t ftp_links < <(tail -n +2 XXXXXXXX.sdrf.txt | cut -f30)
mapfile -t ftp_names < <(tail -n +2 XXXXXXXX.sdrf.txt | cut -f28)

mkdir -p "${fastq_dir}"
for i in ${!ftp_links[@]};
do
  wget --no-verbose -O "${fastq_dir}${ftp_names[${i}]}" "${ftp_links[${i}]}"
done
```


# Getting the human genome annotation and index

Downloaded `r date()`.

* GRCh38 genome annotation was downloaded from Ensembl.

* GRCh38 genome index for HISAT2 was downloaded from the Amazon open data repository.

```{bash, message=FALSE, eval=TRUE}
source shell_variables_RNA-seq.sh

mkdir -p "${genome_dir}"

# genome annotation
wget -N --no-verbose --directory-prefix="${genome_dir}"  http://ftp.ensembl.org/pub/release-103/gff3/homo_sapiens/Homo_sapiens.GRCh38.103.chr.gff3.gz

# genome index for HISAT2
wget -N --no-verbose --directory-prefix="${genome_dir}" https://genome-idx.s3.amazonaws.com/hisat/grch38_tran.tar.gz
tar -zxf "${genome_dir}grch38_tran.tar.gz" --strip-components 1 --directory "${genome_dir}"
rm "${genome_dir}grch38_tran.tar.gz"

# genome sequence
#wget -N --no-verbose --directory-prefix="${genome_dir}" http://ftp.ensembl.org/pub/release-103/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.toplevel.fa.gz
#gzip -fd "${genome}"
```


# QC of raw sequence reads

* strand-specific libraries were sequenced at the Institute of Molecular Genetics, Czech Academy of Sciences.

* Technical quality of library construction and sequencing run was tested using fastQC.

```{bash}
fastqc --version
multiqc --version
```

```{bash, eval=TRUE}
source shell_variables_RNA-seq.sh

mkdir -p "${QC_dir}"
mapfile -t fastq_files < <(ls -1 "${fastq_dir}" | grep "${fastq_file_ext}")
for i in ${fastq_files[@]};
do
  fastqc --quiet --outdir "${QC_dir}" --threads "${CPU}" "${fastq_dir}${i}"
done

multiqc -f -m fastqc -i RNA-seq -o "${QC_dir}" "${QC_dir}"
```

Results of QC:

* 76 nt SE reads

* 16.9-2.3M reads per sample

* read quality scores deteriorate towards the 3' end, trimming will be needed

* small adapter contamination detected (in <4% reads) and will be trimmed

* all samples give warning/error on read duplication levels (expected for RNA-seq)

* all samples give warning on per base sequence content (normal for random-primed RT)

* all samples give warning/error on overrepresented sequences (TruSeq adapters, homopolymers)

* 14 samples give warning on GC content (all 24 profiles look similar and are NOT a nice bell-shaped curve)


# Read trimming

* Remove Illumina adapters.

* Trim parts of the reads where average base quality in a 4 nt window drops below 20.

* Only keep trimmed reads that are at least 20 nt long.

```{bash}
source shell_variables_RNA-seq.sh

java -jar "${trimmomatic_dir}trimmomatic-0.39.jar" -version
```

```{bash, eval=TRUE}
source shell_variables_RNA-seq.sh

mkdir -p "${fastq_trim_dir}"
fastq_files=( $(ls -1 "${fastq_dir}") )
for i in ${fastq_files[@]};
do
  java -jar "${trimmomatic_dir}trimmomatic-0.39.jar" SE -phred33 -threads "${CPU}" "${fastq_dir}${i}" "${fastq_trim_dir}${i}.trim.fastq.gz" ILLUMINACLIP:"${trimmomatic_dir}adapters/TruSeq3-PE-2.fa:2:30:10" SLIDINGWINDOW:4:20 MINLEN:20
done
```


# QC of quality-trimmed sequence reads

Effects of trimming were determined by `fastQC`.

```{bash, eval=FALSE}
source shell_variables_RNA-seq.sh

mkdir -p "${QC_trim_dir}"
fastq_files=( $(ls -1 "${fastq_trim_dir}") )
for i in ${fastq_files[@]};
do
  fastqc --quiet --outdir "${QC_trim_dir}" --threads "${CPU}" "${fastq_trim_dir}${i}"
done

multiqc -f -m fastqc -i RNA-seq_trimmed -o "${QC_trim_dir}" "${QC_trim_dir}"
```

Results of QC:

* dropped 4.6-6.6% of reads

* 20-65 nt reads (vast majority of reads are >63 nt)

* read quality scores now OK

* adapters were removed

* 2 samples give warning on GC content (not sure why)


# Read mapping into the human genome

```{bash}
hisat2 --version
samtools --version
```

```{bash, eval=FALSE}
source shell_variables_RNA-seq.sh

# build HISAT2 index
hisat2-build --quiet -p "${CPU}" "${genome}" "${genome}"

# map
mkdir -p "${bam_dir}"
mapfile -t fastq_files < <(ls -1 "${fastq_trim_dir}")
for i in ${fastq_files[@]};
do
	infile="${fastq_trim_dir}${i}"
	outfile="${bam_dir}${i}.bam"
  echo "${outfile}"
	hisat2 -x "${genome}" -U "${infile}" --threads "${CPU}" --max-intronlen 2600 -k 15 --summary-file "${outfile}.log" | samtools view -b -F 256 --threads "${CPU}" - | samtools sort --threads "${CPU}" -o "${outfile}" - 
	samtools index "${outfile}"
	samtools view -c --threads "${CPU}" "${outfile}"
done
```

Notes

* Since signal is expected at repeat regions, HISAT was set to search for up to 15 matching positions (this allows even for testing all Tf2 and dh/dg repeats in the genome), then only the best (marked as primary by HISAT) alignment was kept.

* Mapping rate was >98%.


# QC of mapped samples

WARNING - completion of this step can take A LOT of time!

```{bash}
deeptools --version
```

```{bash, eval=FALSE}
source shell_variables_RNA-seq.sh

mkdir -p "${image_dir}"
mapfile -t bam_files < <(ls -1 -d "${bam_dir}"* | grep "\.bam$")
multiBamSummary bins --binSize "${bin_size}" -p "${CPU}" -o "${bam_dir}${bam_summary_file}" --bamfiles "${bam_files[@]}"
plotPCA -in "${bam_dir}${bam_summary_file}" -o "${image_dir}RNA-seq_plotPCA.pdf"
plotCorrelation -in "${bam_dir}${bam_summary_file}" -o "${image_dir}RNA-seq_plotCorrelation.pdf" --corMethod pearson --whatToPlot heatmap --removeOutliers
```

* Samples nicely cluster together according to attributes: asynchronous / synchronized, and WT / nse3mut.


# Calculate genome coverage tracks

```{bash, eval=FALSE}
source shell_variables_RNA-seq.sh

mkdir -p "${coverage_dir}"

# calculate coverage
mapfile -t bam_files < <(ls -1 "${bam_dir}" | grep "\.bam$")
for i in ${!bam_files[@]};
do
	input_file="${bam_dir}${bam_files[${i}]}"
	bamCoverage --binSize "${bin_size}" --normalizeUsing CPM -p "${CPU}" --bam "${input_file}" -o "${coverage_dir}${bam_files[${i}]}.bw"
done

# average coverage tracks across biological replicates
samples=("WT_async" "WT_HU" "nse3mut_async" "nse3mut_HU")
lib_IDs=("1|2|9|10" "7|8|15|16" "3|4|11|12" "5|6|13|14")
for i in {0..3};
do
  mapfile -t bw_files < <(ls -1 -d "${coverage_dir}"* | grep -E "_(${lib_IDs[${i}]})_.*\.bam\.bw$")
  wiggletools mean "${bw_files[@]}" | wigToBigWig -itemsPerSlot="${bin_size}" stdin "${genome_dir}chrom.sizes" "${coverage_dir}${samples[${i}]}.mean.bw"
done
```

Notes

* Checked visually in IGV → OK.

* Samples are very coherent across replicates.

* Stress genes are noticebly induced in HU.


# Identify differentially expressed genes

## Generate gene-level counts tables.

* Raw count data are needed for DEG calling in `DESeq2`.

* TPM-normalized (Transcripts Per Million) count data are suitable for general comparisons of the samples.

```{r, eval=TRUE}
gff <- import.gff3(genome_gff)
gff.genes <- gff[gff$type == 'gene', ]
bam_files <- list.files(bam_dir, full.names = TRUE, pattern = '\\.bam$')
bam <- BamFileList(bam_files, yieldSize = 1000000)

sample_info <- read.delim('sampleInfo', stringsAsFactors = FALSE, header = TRUE, sep = '\t')
sample_info[, 'cultivation_run'] <- factor(sample_info[, 'cultivation_run'])
sample_info[, 'genotype'] <- factor(sample_info[, 'genotype'])
sample_info[, 'sync'] <- factor(sample_info[, 'sync'])
names(bam) <- sample_info$sample_ID

se <- summarizeOverlaps(gff.genes,
                        bam,
                        mode = 'Union',
                        singleEnd = TRUE,
                        ignore.strand = FALSE,
                        preprocess.reads = invertStrand)
rownames(se) <- gff.genes$ID
colData(se) <- cbind(colData(se), sample_info)
#save(se, file = 'se.rda')
#load(file = 'se.rda')

counts <- assay(se)

# normalize to get TPM values (transcripts per million)
gene_widths <- width(gff.genes)
counts.norm <- counts
for (i in 1:nrow(counts.norm)){
  counts.norm[i, ] <- counts.norm[i, ] / gene_widths[i]
}
count_sums <- colSums(counts.norm) / 1000000
for (i in 1:length(count_sums)){
  counts.norm[, i] <- counts.norm[, i] / count_sums[i]
}

counts <- cbind(gff.genes$Name, counts)
counts.norm <- cbind(gff.genes$Name, counts.norm)
colnames(counts)[1] <- 'gene_name'
colnames(counts.norm)[1] <- 'gene_name'
write.csv(counts, file = paste0(coverage_dir, 'counts.csv'), quote = FALSE)
write.csv(counts.norm, file = paste0(coverage_dir, 'counts.TPM-normalized.csv'), quote = FALSE)
rm(gene_widths, count_sums)
```

## DEG calling

```{r, eval=TRUE}
# Benjamini-Hochberg p value adjustment (FDR)
padj_threshold <- 0.05

dir.create(deg_dir, showWarnings = FALSE)

# nse3mut asynchronous vs WT asynchronous
dds <- DESeqDataSet(se, design = ~ cultivation_run + genotype)
dds <- dds[, dds$sync =='async'] # remove HU samples
dds$sync <- droplevels(dds$sync) # remove factor levels without samples
dds$genotype <- relevel(dds$genotype, ref = 'WT') # change order of factor levels to get mut/WT fold change (= define the reference)
dds <- DESeq(dds)
res <- results(dds, alpha = padj_threshold)
summary(res[res$padj <= padj_threshold & !is.na(res$padj), ])
res <- cbind(counts[, 'gene_name'], res)
colnames(res)[1] <- 'gene_name'
write.csv(res, file = paste0(deg_dir, 'DESeq2results_nse3mut-async_vs_WT-async.csv'), quote = FALSE)
res.sig <- res[which(res$padj <= padj_threshold), ]
res.sig <- res.sig[order(res.sig$log2FoldChange), ]
write.csv(res.sig, file = paste0(deg_dir, 'DESeq2results_nse3mut-async_vs_WT-async.SIG.csv'), quote = FALSE)
rm(res, res.sig, dds)

# nse3mut HU vs WT HU
dds <- DESeqDataSet(se, design = ~ cultivation_run + genotype)
dds <- dds[, dds$sync =='HU'] # remove asynchronous samples
dds$sync <- droplevels(dds$sync) # remove factor levels without samples
dds$genotype <- relevel(dds$genotype, ref = 'WT') # change order of factor levels to get mut/WT fold change (= define the reference)
dds <- DESeq(dds)
res <- results(dds, alpha = padj_threshold)
summary(res[res$padj <= padj_threshold & !is.na(res$padj), ])
res <- cbind(counts[, 'gene_name'], res)
colnames(res)[1] <- 'gene_name'
write.csv(res, file = paste0(deg_dir, 'DESeq2results_nse3mut-HU_vs_WT-HU.csv'), quote = FALSE)
res.sig <- res[which(res$padj <= padj_threshold), ]
res.sig <- res.sig[order(res.sig$log2FoldChange), ]
write.csv(res.sig, file = paste0(deg_dir, 'DESeq2results_nse3mut-HU_vs_WT-HU.SIG.csv'), quote = FALSE)
rm(res, res.sig, dds)

# nse3mut HU vs nse3mut async
dds <- DESeqDataSet(se, design = ~ cultivation_run + sync)
dds <- dds[, dds$genotype =='nse3mut'] # remove WT samples
dds$genotype <- droplevels(dds$genotype) # remove factor levels without samples
dds$sync <- relevel(dds$sync, ref = 'async') # change order of factor levels to get HU/async fold change (= define the reference)
dds <- DESeq(dds)
res <- results(dds, alpha = padj_threshold)
summary(res[res$padj <= padj_threshold & !is.na(res$padj), ])
res <- cbind(counts[, 'gene_name'], res)
colnames(res)[1] <- 'gene_name'
write.csv(res, file = paste0(deg_dir, 'DESeq2results_nse3mut-HU_vs_nse3mut-async.csv'), quote = FALSE)
res.sig <- res[which(res$padj <= padj_threshold), ]
res.sig <- res.sig[order(res.sig$log2FoldChange), ]
write.csv(res.sig, file = paste0(deg_dir, 'DESeq2results_nse3mut-HU_vs_nse3mut-async.SIG.csv'), quote = FALSE)
rm(res, res.sig, dds)
```


***

```{r}
sessionInfo()
```

